# Run this in Windows Command Prompt after executing the FastAPI server:
# curl -X GET "http://localhost:8000/translate-files/"

from fastapi import FastAPI, HTTPException
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_groq import ChatGroq
import os
import json
import glob
from dotenv import load_dotenv
import re

# Load environment variables from .env file
load_dotenv()

# Initialize the Groq model with the specified parameters
model = ChatGroq(model="llama-3.2-90b-text-preview", groq_api_key='your groq api key', temperature=0.0)

# Define the system prompt template for concise translation to Arabic
sys_template = "Translate the following sentence into Arabic concisely, ensuring no extra words."

# Parser for processing model output
parser = StrOutputParser()

# Define the FastAPI app with metadata
app = FastAPI(
    title="Language Translator",
    version="1.0",
    description="Simple Language Translator using Langchain runnable interfaces and Fast API Server"
)

# Function to clean and adjust the translation output by removing unwanted characters
def clean_translation(text):
    # Remove non-Arabic characters using regex
    arabic_text = re.sub(r'[^\u0600-\u06FF\s.,/؛؟!،]', '', text).strip()
    return arabic_text.strip()

# Translate a list of instructions
async def translate_instructions(instructions):
    translations = []
    for instruction in instructions:
        if isinstance(instruction, list):
            # Handle a list of sentences separately
            translated_sentences = []
            for sentence in instruction:
                # Create and format prompt for each sentence
                prompt_template = ChatPromptTemplate.from_messages([
                    ("system", sys_template),
                    ("user", sentence)
                ])
                
                # Execute the translation process
                chain = prompt_template | model | parser

                try:
                    # Get translated sentence
                    translated_sentence = chain.invoke({"input": sentence})
                    
                    # Clean the translation result
                    cleaned_translated = clean_translation(translated_sentence)

                    # Add cleaned translation to list
                    translated_sentences.append(cleaned_translated)
                except Exception as e:
                    print(f"Error translating sentence '{sentence}': {e}")

            # Append the list of translated sentences
            translations.append(translated_sentences)
        else:
            # Handle a single instruction
            prompt_template = ChatPromptTemplate.from_messages([
                ("system", sys_template),
                ("user", instruction)
            ])
            
            chain = prompt_template | model | parser
            
            try:
                # Get translated instruction
                translated_instruction = chain.invoke({"input": instruction})
                cleaned_translated = clean_translation(translated_instruction)
                translations.append([cleaned_translated])  # Wrap single string in list
            except Exception as e:
                print(f"Error translating instruction '{instruction}': {e}")

    # Return the translations, handling both single and multiple instructions
    return translations[0] if len(translations) == 1 else translations

# Endpoint to translate files and save the translated data
@app.get("/translate-files/")
async def translate_data():
    try:
        # Create output directory for translated files
        output_dir = "translated_annotations"
        os.makedirs(output_dir, exist_ok=True)

        # Process each JSON file in the specified directory
        for file_path in glob.glob("datasets/R2R/annotations/*.json"):
            with open(file_path, 'r', encoding='utf-8') as file:
                data = json.load(file)
                print(f"Processing file: {file_path}")

                # Define output path for translated file
                output_file_path = os.path.join(output_dir, os.path.basename(file_path).replace('.json', '.translated.json'))
                
                # Write translated data to output file
                with open(output_file_path, 'w', encoding='utf-8') as outfile:
                    outfile.write('[\n')  # Start the JSON array

                    # Track indentation level
                    indent_level = 1
                    base_indent = "  "  # Indent by 2 spaces

                    for idx, item in enumerate(data):
                        # Check if the item contains "instruction" or "instructions" key
                        instructions_key = "instruction" if "instruction" in item else "instructions" if "instructions" in item else None
                        
                        if instructions_key:
                            instructions = [item[instructions_key]]
                            translated = await translate_instructions(instructions)
                            item[instructions_key] = translated  # Replace with translated content
                        
                        # Convert item to JSON with initial 2-space indentation
                        json_item = json.dumps(item, ensure_ascii=False, indent=0)
                        json_lines = json_item.splitlines()  # Split JSON string into lines for custom indentation

                        for line in json_lines:
                            # Adjust indentation level for each line based on `{`, `}`, `[`, `]`
                            if line.strip().startswith("}") or line.strip().startswith("]"):
                                indent_level -= 1

                            # Apply the current indentation level
                            outfile.write(f"{base_indent * indent_level}{line}\n")

                            # Increase indentation after `{` or `[`
                            if line.strip().endswith("{") or line.strip().endswith("["):
                                indent_level += 1

                        
                        # Add comma after each item except the last one
                        if idx < len(data) - 1:
                            outfile.write(',\n')
                        else:
                            outfile.write('\n')

                    outfile.write(']')  # Close the JSON array

        # Return a success message
        return {"message": "Translations completed and saved with original file structure intact."}

    except Exception as e:
        # Return error message if an exception occurs
        raise HTTPException(status_code=500, detail=str(e))

# Run the FastAPI app if this script is executed directly
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="localhost", port=8000)
